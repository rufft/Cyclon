schema {
  query: Query
  mutation: Mutation
}

type Batch implements Node {
  id: ID!
  number: Int!
  name: String!
  displayTypeId: UUID!
  displayType: DisplayType!
  displayColor: DisplayColor!
  status: BatchStatus!
  cover: Cover!
  description: String
  displays: [Display!]!
  creationTime: DateTime!
  modificationTime: DateTime!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: String
}

type Display implements Node {
  id: ID!
  displayTypeId: UUID!
  displayType: DisplayType!
  coordinates: Coordinates!
  batchId: UUID!
  batch: Batch!
  color: DisplayColor!
  originalPhotoPath: String
  croppedPhotoPath: String
  comment: String
  creationTime: DateTime!
  modificationTime: DateTime!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: String
}

type DisplayType implements Node {
  id: ID!
  name: String!
  amountRows: Int!
  amountColumns: Int!
  amountDisplays: Int!
  cornersFormat: [[Int!]!]!
  resolution: Size!
  format: Size!
  screenSize: Size!
  comment: String
  batches: [Batch!]!
  displays: [Display!]!
  creationTime: DateTime!
  modificationTime: DateTime!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: String
}

type BaseEntity implements Node {
  id: ID!
  creationTime: DateTime!
  modificationTime: DateTime!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: String
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

type Query {
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  displayTypes("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DisplayTypeFilterInput order: [DisplayTypeSortInput!]): DisplayTypesConnection
  displays("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DisplayFilterInput order: [DisplaySortInput!]): DisplaysConnection
  batches("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: BatchFilterInput order: [BatchSortInput!]): BatchesConnection
}

type Mutation {
  createBatch(input: BatchCreateDtoInput!): ResponseOfBatch!
  updateBatch(input: BatchUpdateDtoInput!): ResponseOfBatch!
  softDeleteBatch(batchId: String!): ResponseOfInt32!
  restoreBatch(batchId: String!): ResponseOfInt32!
  createDisplayType(input: DisplayTypeCreateDtoInput!): ResponseOfDisplayType!
  updateDisplayType(input: DisplayTypeUpdateDtoInput!): ResponseOfDisplayType!
  softDeleteDisplayType(displayTypeId: String!): ResponseOfInt32!
  restoreDisplayType(displayTypeId: String!): ResponseOfInt32!
}

scalar UUID

enum DisplayColor {
  RED
  GREEN
  BLUE
  WHITE
  FULL_COLOR
}

enum BatchStatus {
  SPUTTERED
  GLUED
  CHOPED
  CHECKED
  PARTIALLY_ASSEMBLED
  ASSEMBLED
}

enum Cover {
  NONE
  FIRST
  SECOND
  THIRD
  FOURTH
  FIFTH
  SIXTH
  SEVENTH
  EIGHTH
  NINTH
  TENTH
  ELEVENTH
  TWELFTH
  THIRTEENTH
  FOURTEENTH
  FIFTEENTH
  SIXTEENTH
  SEVENTEENTH
  EIGHTEENTH
  NINETEENTH
  TWENTEENTH
  ALL
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

type Coordinates {
  x: String!
  y: String!
}

type Size {
  width: Float!
  height: Float!
}

input DisplayTypeFilterInput {
  and: [DisplayTypeFilterInput!]
  or: [DisplayTypeFilterInput!]
  name: StringOperationFilterInput
  amountRows: IntOperationFilterInput
  amountColumns: IntOperationFilterInput
  amountDisplays: IntOperationFilterInput
  cornersFormat: ListListIntOperationFilterInput
  resolution: SizeFilterInput
  format: SizeFilterInput
  screenSize: SizeFilterInput
  comment: StringOperationFilterInput
  batches: ListFilterInputTypeOfBatchFilterInput
  displays: ListFilterInputTypeOfDisplayFilterInput
  id: IdOperationFilterInput
  creationTime: DateTimeOperationFilterInput
  modificationTime: DateTimeOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  deletedAt: DateTimeOperationFilterInput
  deletedBy: StringOperationFilterInput
}

input DisplayTypeSortInput {
  name: SortEnumType
  amountRows: SortEnumType
  amountColumns: SortEnumType
  amountDisplays: SortEnumType
  resolution: SizeSortInput
  format: SizeSortInput
  screenSize: SizeSortInput
  comment: SortEnumType
  id: SortEnumType
  creationTime: SortEnumType
  modificationTime: SortEnumType
  isDeleted: SortEnumType
  deletedAt: SortEnumType
  deletedBy: SortEnumType
}

input DisplayFilterInput {
  and: [DisplayFilterInput!]
  or: [DisplayFilterInput!]
  displayTypeId: UuidOperationFilterInput
  displayType: DisplayTypeFilterInput
  coordinates: CoordinatesFilterInput
  batchId: UuidOperationFilterInput
  batch: BatchFilterInput
  color: DisplayColorOperationFilterInput
  originalPhotoPath: StringOperationFilterInput
  croppedPhotoPath: StringOperationFilterInput
  comment: StringOperationFilterInput
  id: IdOperationFilterInput
  creationTime: DateTimeOperationFilterInput
  modificationTime: DateTimeOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  deletedAt: DateTimeOperationFilterInput
  deletedBy: StringOperationFilterInput
}

input DisplaySortInput {
  displayTypeId: SortEnumType
  displayType: DisplayTypeSortInput
  coordinates: CoordinatesSortInput
  batchId: SortEnumType
  batch: BatchSortInput
  color: SortEnumType
  originalPhotoPath: SortEnumType
  croppedPhotoPath: SortEnumType
  comment: SortEnumType
  id: SortEnumType
  creationTime: SortEnumType
  modificationTime: SortEnumType
  isDeleted: SortEnumType
  deletedAt: SortEnumType
  deletedBy: SortEnumType
}

input BatchFilterInput {
  and: [BatchFilterInput!]
  or: [BatchFilterInput!]
  number: IntOperationFilterInput
  name: StringOperationFilterInput
  displayTypeId: UuidOperationFilterInput
  displayType: DisplayTypeFilterInput
  displayColor: DisplayColorOperationFilterInput
  status: BatchStatusOperationFilterInput
  cover: CoverOperationFilterInput
  description: StringOperationFilterInput
  displays: ListFilterInputTypeOfDisplayFilterInput
  id: IdOperationFilterInput
  creationTime: DateTimeOperationFilterInput
  modificationTime: DateTimeOperationFilterInput
  isDeleted: BooleanOperationFilterInput
  deletedAt: DateTimeOperationFilterInput
  deletedBy: StringOperationFilterInput
}

input BatchSortInput {
  number: SortEnumType
  name: SortEnumType
  displayTypeId: SortEnumType
  displayType: DisplayTypeSortInput
  displayColor: SortEnumType
  status: SortEnumType
  cover: SortEnumType
  description: SortEnumType
  id: SortEnumType
  creationTime: SortEnumType
  modificationTime: SortEnumType
  isDeleted: SortEnumType
  deletedAt: SortEnumType
  deletedBy: SortEnumType
}

"A connection to a list of items."
type DisplayTypesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DisplayTypesEdge!]
  "A flattened list of the nodes."
  nodes: [DisplayType!]
}

"A connection to a list of items."
type DisplaysConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DisplaysEdge!]
  "A flattened list of the nodes."
  nodes: [Display!]
}

"A connection to a list of items."
type BatchesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [BatchesEdge!]
  "A flattened list of the nodes."
  nodes: [Batch!]
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input IntOperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input ListListIntOperationFilterInput {
  all: ListIntOperationFilterInput
  none: ListIntOperationFilterInput
  some: ListIntOperationFilterInput
  any: Boolean
}

input SizeFilterInput {
  and: [SizeFilterInput!]
  or: [SizeFilterInput!]
  width: FloatOperationFilterInput
  height: FloatOperationFilterInput
}

input ListFilterInputTypeOfBatchFilterInput {
  all: BatchFilterInput
  none: BatchFilterInput
  some: BatchFilterInput
  any: Boolean
}

input ListFilterInputTypeOfDisplayFilterInput {
  all: DisplayFilterInput
  none: DisplayFilterInput
  some: DisplayFilterInput
  any: Boolean
}

input IdOperationFilterInput {
  eq: ID
  neq: ID
  in: [ID]
  nin: [ID]
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

enum SortEnumType {
  ASC
  DESC
}

input SizeSortInput {
  width: SortEnumType
  height: SortEnumType
}

input UuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

input CoordinatesFilterInput {
  and: [CoordinatesFilterInput!]
  or: [CoordinatesFilterInput!]
  x: StringOperationFilterInput
  y: StringOperationFilterInput
}

input DisplayColorOperationFilterInput {
  eq: DisplayColor
  neq: DisplayColor
  in: [DisplayColor!]
  nin: [DisplayColor!]
}

input CoordinatesSortInput {
  x: SortEnumType
  y: SortEnumType
}

input BatchStatusOperationFilterInput {
  eq: BatchStatus
  neq: BatchStatus
  in: [BatchStatus!]
  nin: [BatchStatus!]
}

input CoverOperationFilterInput {
  eq: Cover
  neq: Cover
  in: [Cover!]
  nin: [Cover!]
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

"An edge in a connection."
type DisplayTypesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DisplayType!
}

"An edge in a connection."
type DisplaysEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Display!
}

"An edge in a connection."
type BatchesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Batch!
}

input ListIntOperationFilterInput {
  all: IntOperationFilterInput
  none: IntOperationFilterInput
  some: IntOperationFilterInput
  any: Boolean
}

input FloatOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float]
  nin: [Float]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input DisplayTypeUpdateDtoInput {
  id: ID!
  name: String
  resolution: SizeDtoInput
  format: SizeDtoInput
  screenSize: SizeDtoInput
  comment: String
}

input DisplayTypeCreateDtoInput {
  name: String!
  resolution: SizeDtoInput!
  format: SizeDtoInput!
  screenSize: SizeDtoInput!
  amountRows: Int!
  amountColumns: Int!
  cornersFormat: [[Int!]!]!
  comment: String
}

type ResponseOfDisplayType {
  success: Boolean!
  failure: Boolean!
  data: DisplayType
  message: String
  errors: [String!]!
}

type ResponseOfInt32 {
  success: Boolean!
  failure: Boolean!
  data: Int!
  message: String
  errors: [String!]!
}

input BatchUpdateDtoInput {
  id: ID!
  number: Int
  name: String
  color: String
  status: String
  description: String
}

input BatchCreateDtoInput {
  number: Int!
  name: String!
  displayTypeId: ID!
  color: String!
  cover: [Int!]
  description: String
}

type ResponseOfBatch {
  success: Boolean!
  failure: Boolean!
  data: Batch
  message: String
  errors: [String!]!
}

input SizeDtoInput {
  width: Float!
  height: Float!
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize("The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field." assumedSize: Int "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments." slicingArguments: [String!] "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query." slicingArgumentDefaultValue: Int "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields." sizedFields: [String!] "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error." requireOneSlicingArgument: Boolean! = true) on FIELD_DEFINITION

"The @lookup directive is used within a source schema to specify output fields\nthat can be used by the distributed GraphQL executor to resolve an entity by\na stable key."
directive @lookup on FIELD_DEFINITION